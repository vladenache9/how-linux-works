									              Task 1 : Linux basics
									              
	Informative note : In this text document , I'll type in English for my own good , for the future ( to be prepared and capable of speaking , typing and communicating in English) . Also everything in this document will be written by myself  and from the book 'How Linux Works' (also inspired from different sources on the Internet)  but not  generated by artificial intelligence . With that being said , I'm sorry if there will be any grammatical mistakes or other problems . 	
	
	Chapter 1 : THE BIG PICTURE 
	Top 3 new things learned from this chapter : 
	1. One of the new things that I learned from this chapter is how context switch works (Chapter 1.3.1) .  Although nowadays we have on the market , multi-core CPU's , it seems fascinating to me that back in the day existed systems with one-core CPU and because of the fact that there was just one core , many processes were able to use the CPU , but only one could actually use the CPU at anytime . 
	2. The second thing that caught my attention the most in this chapter is the information about MMU ( Chapter 1.3.2) . The MMU is available on modern CPU's and enables a memory access scheme called virtual memory . The interesting thing is that when the process accesses some of its memory , the MMU intercepts the access and uses a memory address map to translate the memory location from the process point of view into an actual physical memory location in the machine . During a context switch , the kernel has to change the map from the outgoing process to the incoming procces . In my opinion , this technology called "MMU" completely changed the CPU's industry and helped us ( intensive PC users) to evolve and work much faster at our computers . 
	3. I was always curious what's actually the kernel doing when I'm typing a command  in the terminal . Chapter 1.3.4 helped me figure out with the information about System Calls and Support . Basically , when we are typing a commmand into a terminal  ls , the shell calls "fork()" to create a copy of the shell and the new copy of the shell calls "exec(ls)" to execute/run "ls" . It is a process that I didn't know was happening in the back of the terminal window and I'm glad I learned about it .
	
	Chapter 2 : BASIC COMMANDS AND DIRECTORY HIERARCHY
	Top 3 new things learned from this chapter : 
	1. The most important thing that I learned in this chapter is about Running Commands as the Superuser(Chapter 2.20) .  In my case , as a Linux beginner user , I always tried to "explore" my Linux distrubtions , for example : to customize it at every level , to "play" in the terminal non-stop , to install everything on it just so I can learn from my mistakes . I used several types of distributions , like Fedora , POP Os , DeepIn ,  Ubuntu , LinuxMint (which seemed the most reliable for myself) even Manjaro , Garuda and etc  . Now after a period of time of using different Linux distributions and after somehow destroying some of them ( unintentionally) just by trying to customize everything , to add a new widget everywhere etc I realised from this chapter of the course that maybe I used too much the root priviliges , because like in the course says : "You may be tempted to start a root shell , but doing so has many disadvantages" . This is exactly what I did on every Linux distribution that I used , just out of curiosity to find out what happens if I do something in the shell as a root . As the course says when you start a root shell , the biggest disadvantage is that you have no record of system-altering commands which is very dangerous and it can cause different problems like mine ( your system suddenly stops working or some important functionalities just bugged) . Taking in consideration these facts , I learned that I should stop being "curious" about programming in a shell as a root(without knowing exactly what's going to happen)  or benefitting every time of the root privileges.
	2. The chapter 2.17.1 - Modifying Permissions also taught me to change my permissions through the command : 'chmod' . The thing that I like about this command is that I can modify specifically for every directory or file the permissions (  to read/ write ) . Everyone has personal files/documents that are for 'his eyes only' and I appreciate the fact that through this command I can keep my personal stuff for my eyes only . 
	3. In the 2.19 chapter I learned about Linux Directory Hierarchy Essentials . Using Linux , I already viewed those directories but with the help of this chapter I specifically learned what every directory includes . From now on , at least when I'm looking for something in my system , I know where to look/search ( example : I want to see exactly what I did 2 days ago , how much I stayed logged in . I can find a lot of these informations in the /var directory ) . 
	
	Chapter 3: DEVICES
	Top 3 new things learned from this chapter : 
	1. Although at first it seemed a little bit complicated for me to understand this process , now it seems very useful . In chapter 3.3(dd and Devices) I learned that 'dd' copies data in blocks of a fixed size , but on the other hand , it's very dangerous because it's easy to corrupt files and data on devices by making a careless mistake . Also , the 'count-num' command seemed very useful because it counts the total number of blocks to copy  . 
	2. In the chapter 3.4.1(Hard Disks:/dev/sd) I learned that in my case ( with 3 disks ) if /dev/sdc explodes and I must remove it so the machine can work again , the former /dev/sdc moves to /dev/sdb (there's no longer /dev/sdc) . It's good to know for me in the future , because maybe that could happen to my system by mistake and I'll know what happened with my disks( to use the UUID-Universally Unique Identifier). 
	3. To find out about more information about my disk , I learned from chapter 3.2 (The sysfs Device Path ) . For example , typing the command : ' $ udevadm info --query=all --name=/dev/sda' , I fing a lot of additional informations about my disk  like : the type of device , the device path and different functionalities ( write_cache_enabled/disabled , feature_set_security_enabled/disabled etc ) . 
	
	Chapter 4: DISKS AND FILESYSTEMS
	Top 3 new things learned from this chapter : 
	1. In the chapter 4.1.3(Create a Partition Table) I learned how to create a partition table which is important to everyone who for example buys a new disk and want to create a partition . It's very easy to do so , by first finding your own device location with 'lsblk' and after that typing 'fdisk/dev/sd_ ' . 
	2. Another important thing that I learned is how to mount a Filesystem( Chapter 4.2.3) . I like this command because it's efficient , precise and very easy to use . For example I first typed 'mount' in the terminal to see the device where I wanted to mount my filesystem . I found ' /dev/sdc2/' then I typed 'mount ext4 /dev/sdc2 /home/vlad_kali/Task1 ' to create a filesystem where can I transfer my files for this task . 
	3. In chapter 4.2.12(Special-Purpose Filesystems) I learned that not all filesystems represent storage on physical media. The ' tmpfs ' command helps me  use my physical memory and swap space as a temporary storage . Let's take example of a unnecessary memory consumer(in my opinion)  : caching in a web browser ; using tmpfs to store cache it's much faster and reduce the usage of the SSD . (On systems without swap space , tmpfs will consume large amounts of memory) . 

	Chapter 5: HOW THE LINUX KERNEL BOOTS
	Top 3 new things learned from this chapter : 
	1. It might seem funny but the most important thing learned in this chapter is actually a note from chapter 5.4 (Boot Loaders) because until today I thought my system uses a BIOS to boot . Actually thanks to the note from this chapter , by running the command 'efibootmgr' I found out that my system apprently uses UEFI( thought my system was using BIOS , because when I power on the PC , it actually shows to 'press F11 to run BIOS Setup ' ) . Also , another thing that this command help me fix is about the way my system boots  , because using this commnand it shows exactly the boot options and the order of them ( I don't know why but after running the command it shows in the terminal that the boot options are 7 ... it's odd for me because 4 of them are previous OS's that I used in the past . Example : '  Boot0005  deepin , Boot0007  ubuntu , Boot000A  ubuntu ' ) . This command will help me fix my booting options because it's not alright to still appear in the booting options an OS that has been 'erased' from the system .
	2. As I said at Chapter 2 , I like to customize everything on my OS  (including the GRUB) . Thanks to chapter 5.5.2(GRUB configuration) I found out very easily that in every OS exists a GRUB config file . I can either modify the actual grub.cfg or try to modify it by myself which is very cool . All of these can be done also by the command ' # grub-mkconfig -o /boot/grub/grub.cfg' . 
	3. The third thing learned in this chapter is a continuation of the second thing . I also learned to install GRUB on my system(which uses UEFI ) . I found out that if I'm installing it will end up on another system , in my case Windows . Because I'm using a dual-boot system ( 1st SSD : Windows , 2nd SSD: Kali ) and my system  uses UEFI(not BIOS ) the grub installer won't work simply because the Windows will be fighting head to head with the UEFI . Windows versions from 8 and up specifically require to use a secure boot , even though the UEFI accepts to disable this option , so  the GRUB that maybe I would have tried to install wouldn't have worked because of the dual boot (mainly because of the Windows ) . 
	
	Chapter 6: HOW USER SPACE STARTS
	Top 3 new things learned from this chapter : 
	1. In this chapter I learned  how to identify my init . In my system , by exploring the directories , I found : /etc/systemd and in /usr/lib/systemd so my system uses systemd version of init . Systemd is a newer init implementation of Linux and it aims to incoporate the functionality of a number of standard Unix services . 
	2. Second thing which seemed very useful for me because I already in the past I destroyed some systems is how to rescue a system . First step which I always did was to boot the system with another distribution's live image or how from the chapter 6.8(Emergency Booting and Single-User Mode)  I learned to boot with a dedicated rescue image : SystemRescueCD . Also I learned some common tasks to fix the system like : Checking filesystems after a system crash , fixing problems in critical files etc. 
	3. In chapter 6.6(Shutting Down your System) I learned how a command that I already used actually works . I usually used just 'shutdown' command and the system shutdowns in 1 minute , but there are several options to either halt the system immediately or maybe set it a time to reboot . For example 'shutdown -h now' halts the system instantly and 'shutdown -r +10 ' will make the system reboot in 10 minutes .

	Chapter 7: SYSTEM CONFIGURATION: LOGGING,SYSTEM TIME, BATCH JOBS, AND USERS
	Top 3 new things learned from this chapter : 
	1. In the chapter 7.1.2 (Searching and Monitoring Logs ) I learned more details about the command 'journalctl ' . It basically gives me all of my messages in the journal , starting with the oldest ones . But it's nicer because I can put more filters in this command like : 'journalctl -r ' which reveals messages in the reverse time order . Also I enjoyed the most the command 'journalctl -p 3 ' - this command basically shows me the diagnostic messages which actually appear on my screen before the start of the system . In my example in this command I found diagnostic messages like 'x86/cpu: SGX disabled by BIOS ' , 'nouveau 0000:01:00.0: bus: MMIO write of 8000014a FAULT at 10eb14 [ PRIVRING ] ' which will help me fix my system problems .
	2. In chapter 7.2(The structure of /etc) I found out where my most system configuration files on a Linux are : in /etc . This is important because of the fact that I can configure several things like network , the grub or even the password from the etc directory . 
	3. Because I like my data to be private I enjoyed a lot the chapter 7.3.3 and 7.3.4 which explained to me how my password is stored . There exists a shadow password file ( /etc/shadow) which contains user authentification information including encrypted passwords . Also , I found out about the command 'chfn ' and 'chsh' to change the real name and shell . 

	Chapter 8 : A CLOSER LOOK AT PROCESSES AND RESOURCE UTILIZATION
	Top 3 new things learned from this chapter :
	1. In chapter 8.3(Tracing Program Execution and System Calls) I learned about the commands 'strace ' and 'ltrace' . Both commands help me as a user to discover what a program attempts to do . Also , the 'strace' command can be followed by a program name and it works like a troubleshooting .
	2. Using the command 'top' I see an explicit list of priorities in action . For example when I run it it's shown the exactly user that it's a doing an action ( ex. USER: vlad_kali , tine+command : 14:14.71 brave ) . It seems to me that it's like a Task Manager but in a more explicit way and very useful . Also I can see how many resources my CPU uses ( in my case for the most consuming action it's ~39.9% ) . 
	3. Another command that I found interesting it's 'lsof' which lists open files and processes using them . 'lsof' means 'list open files' but let's say that I need to know that process is using a particulary directory or even the opposite , maybe I need to know what files  a particular process has open . For example , I need to know what files  have a particular process has open  , I'll just copy the PID(process ID) and type 'lsof -p 890 ' so I can see additional info about the process.
	
	Chapter 9 : UNDERSTANDING YOUR NETWORK AND ITS CONFIGURATION
	Top 3 new things learned from this chapter :
	1. In chapter 9 , being intereseted in new things , I learned about MAC addresses . In college , I learned a lot about IP addresses/masks , but even though I saw the word 'MAC' a lots of times in my PC ,  I never what it actually does . In my case , with a device with wired connection , I found out that I have a Media Access Control address , also called hardware address .  It is a unique 12-character alphanumeric attribute that is used to identify individual electronic devices on a network . For example my MAC address is : d8:cb:8a:e1:45:38 . 
	2. In chapter 9.25(Firewalls) I also learned about a thing that I saw several times , but  I never knew what it actually does . A firewall is a software and/or hardware configuration that usually sits on a router between the internet and a smaller network. It actually is very useful for the security of a network : it focuses on blocking malware and application-layer attacks . Along with an integrated intrusion prevention system(IPS) , these firewalls are able to react quickly and seamlessly to detect and combat attacks across the whole network . 
	3. Because the lack of addresses in IPv4 , the Internet Engineering Task Force developed a new version , IPv6 (which I learned about in chapter 9.7 . The biggest difference between them is that the IPv4 is a 32-bit IP address and IPv6 is a 128-bit IP address , the number of IP addresses available growing drastically . However , one disadvantage is that the IPv4 is still widely used . Also , communication between IPv4 and IPv6 machines is not directly possible , meaning IPv4 addresses won't be able to see an IPv6 page and vice versa. 
	
	Chapter 10 : NETWORK APPLICATIONS AND SERVICES
	Top 3 new things learned from this chapter :
	1. As I said before in this document , I like to have my data private and all of my network to be secured . In chapter 10.7(Network Security) I found out about some tips to make my system as secure as possible .  I put some of these tips into practice already like : running as few services as possible , I'm not giving any account on my system to anyone who doesn't need one  , I'm avoiding downloading and installing exec software from odd places and I'm not getting root access . 
	2. In chapter 10.3(Network servers) I learned that the use of network servers is to usually operate multiple processes . Here are some network servers that were running on my system : apache-for web servers , sshd - for secure shell daemon and nsfd - for network filesystem daemons . 
	3. In chapter 10.6(Remote Procedure Calls) I found out about remote procedure call(RPC) , a system residing in the lower parts of the application layer . It's designed to make it easier for programmers to build client/server network applications . It works quite well  for a shopping website for example : a client programs calls functions ( he orders a specific clothing item ) that execute on a remote server( the website will receive the command will place it to the customer ) . 
	
	Chapter 11 : INTRODUCTION TO SHELL SCRIPTS
	Top 3 new things learned from this chapter :
	1. In the chapter 11 I learned about Shell Script Basics . A shell script is a computer program designed to be run by the Unix/Linux shell . With shell scripts you can manipulate files , execute programs and print text . With the command 'chmod ' you allow other users to read and execute a script . For example , I like about these commands & scripts that I can run a python program '#!/usr/bin/python' . 
	2. I also like that running a shell script gives you feedback of the script you wrote . This feedback that the shell gives you it's called 'Exit Codes ' , it's numeric value also known as an error code or exit value . When the exit code is zero(0) , it typically means that the program ran without a problem . In my case , I introduced a script and the exit code returned was '1'  because 'there was no actual file or directory ' , but if there is an actual problem the 'Exit Code ' will return the value 2 .
	3. An important shell command that I learned is 'basename' which can be used with other programs and don't often find a place outside shell scripts . For example it can be used to convert gif image files into png files . 
	
	Chapter 12 : NETWORK FILE TRANSFER AND SHARING
	Top 3 new things learned from this chapter :
	1. In chapter I learned to copy files from my Linux machine to another one on my personal network . I can do it with Python with the command : 'python -m SimpleHTTPServer' . This command starts a basic web server that makes the current directory available to any browser on the network . For example I learned that by default it runs on port 8000 and my IP address is : 192.168.1.7 . I simply need to input in my browser 192.168.1.7:8000 and I'll be able to grab what I need . 
	2. For sharing file systems between Linux systems I learned that I can use SSHFS . This opens a SSH connection and presents the files on the other side at a mount point on my machine . 
	3. For cloud storage I used in  the past: Nextcloud .  This had advantages like : I neved had to maintin it and I didn't worry about backups .
	
	Chapter 13 : USER ENVIRONMENTS
	1. In chapter 13 I learned the guidelines for creating startup files . In my case , being the only user , if there appear any errors it affects only me and it's easy enough to fix them .
Also when creating startup files I have to keep it simple and to use comments so I can get a good understanding of what each part of a file does .
	2. I learned that my shell is by default using bash . In bash I can choose from the startup filenames : .bash_profile , .profile , .bash_login and .bashsrc . 
	3. Also I learned that I don't have to put any kind of graphical command in a shell startup file . Not all shells run in graphical environment  , I don't have to run commands in a startup file that print to a standard output. 
	
	Chapter 14 : A BRIEF SURVEY OF THE LINUX DESKTOP AND PRINTING
	Top 3 new things learned from this chapter :
	1. In chapter 14 I found out how to determine exactly what environment I'm using . In my case , I knew my system it's X but for future environments it's good to know the command : '$WAYLAND_DISPLAY ' . If the value is something like 'wayland-0 ' it means I'm running Wayland , but in my system it shows 'command not found' which means I'm running X . 
	2. I learned that X server uses the X Input Extension to manage input from many different devices . To handle more than one of the same type of device simultaneously , the X Input Extension creates a virtual core device that funnels device input to the X server . To see my device configuration on my machine , i ran the 'xinput --list ' command .
	3. At chapter 14.5(D-bus) I learned about Desktop Bus(D-Bus) which is a message-passing system . D-Bus can serve as an interprocess communication mechanism that allows desktop applications to talk to each other . It consists of a library that standardizes interprocess commumnication with a protocol and supporting functions for any two processes to talk to each other . 
	
	Chapter 15 : DEVELOPMENT TOOLS
	Top 3 new things learned from this chapter :
	1. In chapter 15 I learned about the C compiler . Knowing the C programming language I can see the origin of the programs that my Linux system uses . The C compiler executable on most Unix systems is the GNU C compiler (gcc) . C source code files end with .c . 
	2. Another good thing to know is the functionality of 'make ' . The basic idea behind 'make' is the target , a goal that you want to achieve . A target can be a file or a label . To build a target 'make' follows a rule , such as one specifying how to go from a .c source code file to a .o object file . 'make' already knows several rules , but I can customize it to create my own rules .
	3. I know about Java, it's utilities and it is used for but I didn't know that   Java programming language actually has a few niches in a Unix system . It's often used as a web application environment and it's popular for specialized applications . There are two kinds of Java compilers : native compilers for producing machine code for my system and bytecode compiler . Practically I always encounter bytecode on Linux , so this is where Java is present in my system . 
	
	Chapter 16 : INTRODUCTION TO COMPILING SOFTWARE FROM C SOURCE CODE
	Top 3 new things learned from this chapter :
	1. In this chapter I learned some important steps which can help me to even make my own source code . First I have to unpack the source code archive from my system , then the most important step is to configure the package the way I want , run 'make' to build the programs and finnaly to run 'make install' . 
	2. Second thing learned is about the GNU autoconf . GNU autoconf is a popular system for automatic Makefile generation . Packages using this system come with files named 'configure' , 'Makefile.in and 'config.h.in ' . The .in files are templates; the idea is to run the configure script in order to discover the characteristics of your system, and then make substitutions in the .in files to create the real build files.
	3. The installation practice is very important because knowiing how to build and install software is good , but knowing when and where to install my own package is even more useful . The benefits of doing installs on my own are : I can customize package defaults , when installing a package , I get a clearer picture of how to use it , I control the release that I run . 
	
	Chapter 17: VIRTUALIZATION
	Top 3 new things learned from this chapter :
	1. The most useful thing learned from this chapter is about containers . In my case , I saw the word 'Docker' several times and always wanted to know what it actually does . Docker is a container tool , and what is a container ? The ideas that containers are built on is : you're altering the environment and restricting the resources with which processes run . A container can be loosely defined as a restricted runtime environment for a set of processes , the implication being that those processes can't touch anything on the system outside the environment . 
	2. To install Docker on my system , I made a new directory and I created a file called 'Dockerfle' . The following command , reads the Dockerfile in the current directory and applies the identifier 'hlw_test' to the image : 'docker build -t hlw_test' . 
	3. Python's virtual environment feature creates a verion of Python with only the packages that I want . To start I created a new directory for the environment : 'python3 - m venv test-venv ' . To activate the virtual environment , I need to source the test-venv/bin/activate script : '.test-env/bin/activate' . 
